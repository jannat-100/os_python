{
	// Place your snippets for python here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"sjf": {
  "prefix": "bdSJF",
  "body": [
    "def sjf(processes, burst_time):",
    "    n = len(processes)",
    "    zipped = sorted(zip(burst_time, processes))",
    "    burst_time, processes = zip(*zipped)",
    "",
    "    waiting_time = [0] * n",
    "    turnaround_time = [0] * n",
    "",
    "    for i in range(1, n):",
    "        waiting_time[i] = waiting_time[i - 1] + burst_time[i - 1]",
    "    ",
    "    for i in range(n):",
    "        turnaround_time[i] = waiting_time[i] + burst_time[i]",
    "",
    "    print(\"\\nSJF Schedule:\")",
    "    for i in range(n):",
    "        print(f\"P{processes[i]}: Waiting={waiting_time[i]}, Turnaround={turnaround_time[i]}\")",
    "",
    "#test",
    "processes = [1, 2, 3]",
    "burst_time = [5, 2, 8]",
    "sjf(processes, burst_time)"
  ],
  "description": "sjf"
},
"mru": {
  "prefix": "bdMRU",
  "body": [
    "def mru(pages, capacity):",
    "    memory = []",
    "    faults = 0",
    "    for p in pages:",
    "        if p not in memory:",
    "            if len(memory) == capacity:",
    "                memory.pop(-1)",
    "            faults += 1",
    "        else:",
    "            memory.remove(p)",
    "        memory.append(p)",
    "    print(\"Page Faults:\", faults)",
    "",
    "mru([1, 2, 3, 2, 4, 1, 5], 3)",
    ""
  ],
  "description": "mru"
},
"fifo": {
  "prefix": "bdFIFO",
  "body": [
    "def fifo(pages, capacity):",
    "    memory = []",
    "    faults = 0",
    "    for p in pages:",
    "        if p not in memory:",
    "            if len(memory) == capacity:",
    "                memory.pop(0)",
    "            memory.append(p)",
    "            faults += 1",
    "    print(\"Page Faults:\", faults)",
    "",
    "fifo([1, 3, 0, 3, 5, 6], 3)"
  ],
  "description": "fifo"
},
"first_best_worst": {
  "prefix": "bdFIT",
  "body": [
    "def first_fit(holes, process_size):",
    "    for hole in holes:",
    "        if hole >= process_size:",
    "            print(f\"First Fit: {hole}k\")",
    "            return",
    "    print(\"Hey wait, you don't have sufficient space\")",
    "",
    "",
    "def best_fit(holes, process_size):",
    "    holes.sort()",
    "    for hole in holes:",
    "        if hole >= process_size:",
    "            print(f\"Best Fit: {hole}k\")",
    "            return",
    "    print(\"Hey wait, you don't have sufficient space\")",
    "",
    "",
    "def worst_fit(holes, process_size):",
    "    holes.sort(reverse=True)",
    "    if process_size <= holes[0]:",
    "        print(f\"Worst Fit: {holes[0]}k\")",
    "    else:",
    "        print(\"Hey wait, you don't have sufficient space\")",
    "",
    "# Main Logic",
    "n = input(\"Enter the number of Holes available: \")",
    "holes = list(map(int, input(\"Enter the Hole Sizes: \").split()))",
    "",
    "process_size = int(input(\"Enter process size: \"))",
    "",
    "first_fit(holes[:], process_size)   # use holes[:] to pass a copy",
    "best_fit(holes[:], process_size)",
    "worst_fit(holes[:], process_size)"
  ],
  "description": "first_best_worst"
},
"banker": {
  "prefix": "bdBANK",
  "body": [
    "def bankers(n, m, alloc, maxm, avail):",
    "    need = [[maxm[i][j] - alloc[i][j] for j in range(m)] for i in range(n)]",
    "    finish = [False] * n",
    "    safe_seq = []",
    "    work = avail.copy()",
    "",
    "    while len(safe_seq) < n:",
    "        allocated = False",
    "        for i in range(n):",
    "            if not finish[i] and all(need[i][j] <= work[j] for j in range(m)):",
    "                for j in range(m):",
    "                    work[j] += alloc[i][j]",
    "                finish[i] = True",
    "                safe_seq.append(i)",
    "                allocated = True",
    "        if not allocated:",
    "            print(\"System is not in safe state\")",
    "            return",
    "    print(\"Safe sequence:\", \" -> \".join(f\"P{p}\" for p in safe_seq))",
    "",
    "# Example",
    "n = 5  # processes",
    "m = 3  # resources",
    "alloc = [[0, 1, 0], [2, 0, 0], [3, 0, 2], [2, 1, 1], [0, 0, 2]]",
    "maxm = [[7, 5, 3], [3, 2, 2], [9, 0, 2], [2, 2, 2], [4, 3, 3]]",
    "avail = [3, 3, 2]",
    "bankers(n, m, alloc, maxm, avail)"
  ],
  "description": "banker"
},
"fcfs": {
  "prefix": "bdFCFS",
  "body": [
    "# FCFS Scheduling",
    "def fcfs(processes, burst_time):",
    "    n = len(processes)",
    "    wt = [0] * n",
    "    TA = [0] * n",
    "",
    "    for i in range(1, n):",
    "        wt[i] = wt[i - 1] + burst_time[i - 1]",
    "    ",
    "    for i in range(n):",
    "        TA[i] = wt[i] + burst_time[i]",
    "",
    "    print(\"FCFS Schedule:\")",
    "    for i in range(n):",
    "        print(f\"P{processes[i]}: Waiting={wt[i]}, Turnaround={TA[i]}\")",
    "",
    "",
    "#test",
    "processes = [1, 2, 3]",
    "burst_time = [5, 2, 8]",
    "fcfs(processes, burst_time)"
  ],
  "description": "fcfs"
},
"LRU": {
  "prefix": "bdLRU",
  "body": [
    "def lru(pages, capacity):",
    "    memory = []",
    "    faults = 0",
    "    for p in pages:",
    "        if p not in memory:",
    "            if len(memory) == capacity:",
    "                memory.pop(0)",
    "            faults += 1",
    "        else:",
    "            memory.remove(p)",
    "        memory.append(p)",
    "    print(\"Page Faults:\", faults)",
    "",
    "lru([7, 0, 1, 2, 0, 3, 0, 4], 3)"
  ],
  "description": "LRU"
},
"fcfs_arrival": {
  "prefix": "bdFCFSA",
  "body": [
    "# FCFS Scheduling with Arrival Time and Average Waiting Time",
    "def fcfs(processes, arrival_time, burst_time):",
    "    n = len(processes)",
    "    completion_time = [0] * n",
    "    waiting_time = [0] * n",
    "    turnaround_time = [0] * n",
    "",
    "    # Sort processes by arrival time",
    "    zipped = list(zip(arrival_time, burst_time, processes))",
    "    zipped.sort()",
    "    arrival_time, burst_time, processes = zip(*zipped)",
    "",
    "    # First process",
    "    completion_time[0] = arrival_time[0] + burst_time[0]",
    "    turnaround_time[0] = completion_time[0] - arrival_time[0]",
    "    waiting_time[0] = turnaround_time[0] - burst_time[0]",
    "",
    "    # Rest of the processes",
    "    for i in range(1, n):",
    "        if arrival_time[i] > completion_time[i - 1]:",
    "            # CPU idle time",
    "            completion_time[i] = arrival_time[i] + burst_time[i]",
    "        else:",
    "            completion_time[i] = completion_time[i - 1] + burst_time[i]",
    "",
    "        turnaround_time[i] = completion_time[i] - arrival_time[i]",
    "        waiting_time[i] = turnaround_time[i] - burst_time[i]",
    "",
    "    # Print results",
    "    print(\"FCFS Schedule:\")",
    "    for i in range(n):",
    "        print(f\"P{processes[i]}: Arrival={arrival_time[i]}, Burst={burst_time[i]}, Waiting={waiting_time[i]}, Turnaround={turnaround_time[i]}, Completion={completion_time[i]}\")",
    "",
    "    avg_waiting = sum(waiting_time) / n",
    "    avg_turnaround = sum(turnaround_time) / n",
    "",
    "    print(f\"\\nAverage Waiting Time = {avg_waiting:.2f}\")",
    "    print(f\"Average Turnaround Time = {avg_turnaround:.2f}\")",
    "",
    "",
    "# Test",
    "processes = [1, 2, 3]",
    "arrival_time = [0, 1, 2]",
    "burst_time = [5, 2, 8]",
    "fcfs(processes, arrival_time, burst_time)",
    ""
  ],
  "description": "fcfs_arrival"
},
"sjf_arrival": {
  "prefix": "bdSJFA",
  "body": [
    "# SJF (Non-Preemptive) Scheduling Algorithm with Arrival Time",
    "",
    "def sjf(processes, arrival_time, burst_time):",
    "    n = len(processes)",
    "    completed = 0",
    "    current_time = 0",
    "    is_completed = [False] * n",
    "",
    "    waiting_time = [0] * n",
    "    turnaround_time = [0] * n",
    "    completion_time = [0] * n",
    "",
    "    print(\"\\nSJF Schedule:\")",
    "",
    "    while completed != n:",
    "        idx = -1",
    "        min_burst = float('inf')",
    "",
    "        for i in range(n):",
    "            if arrival_time[i] <= current_time and not is_completed[i]:",
    "                if burst_time[i] < min_burst:",
    "                    min_burst = burst_time[i]",
    "                    idx = i",
    "                elif burst_time[i] == min_burst:",
    "                    if arrival_time[i] < arrival_time[idx]:",
    "                        idx = i",
    "",
    "        if idx != -1:",
    "            current_time += burst_time[idx]",
    "            completion_time[idx] = current_time",
    "            turnaround_time[idx] = completion_time[idx] - arrival_time[idx]",
    "            waiting_time[idx] = turnaround_time[idx] - burst_time[idx]",
    "            is_completed[idx] = True",
    "            completed += 1",
    "",
    "            print(f\"P{processes[idx]}: Arrival={arrival_time[idx]}, Burst={burst_time[idx]}, \"",
    "                  f\"Waiting={waiting_time[idx]}, Turnaround={turnaround_time[idx]}, Completion={completion_time[idx]}\")",
    "        else:",
    "            current_time += 1  # CPU is idle",
    "",
    "    avg_waiting = sum(waiting_time) / n",
    "    avg_turnaround = sum(turnaround_time) / n",
    "",
    "    print(f\"\\nAverage Waiting Time = {avg_waiting:.2f}\")",
    "    print(f\"Average Turnaround Time = {avg_turnaround:.2f}\")",
    "",
    "",
    "# Test Example",
    "processes = [1, 2, 3]",
    "arrival_time = [0, 1, 2]",
    "burst_time = [5, 2, 8]",
    "",
    "sjf(processes, arrival_time, burst_time)",
    ""
  ],
  "description": "sjf_arrival"
},
"first_fit": {
  "prefix": "bdFIRST",
  "body": [
    "def first_fit(blocks, processes):",
    "    allocation = [-1] * len(processes)",
    "    for i, p in enumerate(processes):",
    "        for j, b in enumerate(blocks):",
    "            if b >= p:",
    "                allocation[i] = j",
    "                blocks[j] -= p",
    "                break",
    "    print(\"Process\\tSize\\tBlock\")",
    "    for i, a in enumerate(allocation):",
    "        print(f\"{i}\\t{processes[i]}\\t{a if a != -1 else 'Not Allocated'}\")",
    "",
    "first_fit([100, 500, 200, 300, 600], [212, 417, 112, 426])"
  ],
  "description": "first_fit"
},
"best_fit": {
  "prefix": "bdBEST",
  "body": [
    "def best_fit(blocks, processes):",
    "    allocation = [-1] * len(processes)",
    "    for i, p in enumerate(processes):",
    "        best_idx = -1",
    "        for j, b in enumerate(blocks):",
    "            if b >= p and (best_idx == -1 or blocks[j] < blocks[best_idx]):",
    "                best_idx = j",
    "        if best_idx != -1:",
    "            allocation[i] = best_idx",
    "            blocks[best_idx] -= p",
    "    print(\"Process\\tSize\\tBlock\")",
    "    for i, a in enumerate(allocation):",
    "        print(f\"{i}\\t{processes[i]}\\t{a if a != -1 else 'Not Allocated'}\")",
    "",
    "best_fit([100, 500, 200, 300, 600], [212, 417, 112, 426])"
  ],
  "description": "best_fit"
},
"worst_fit": {
  "prefix": "bdWORST",
  "body": [
    "def worst_fit(blocks, processes):",
    "    allocation = [-1] * len(processes)",
    "    for i, p in enumerate(processes):",
    "        worst_idx = -1",
    "        for j, b in enumerate(blocks):",
    "            if b >= p and (worst_idx == -1 or blocks[j] > blocks[worst_idx]):",
    "                worst_idx = j",
    "        if worst_idx != -1:",
    "            allocation[i] = worst_idx",
    "            blocks[worst_idx] -= p",
    "    print(\"Process\\tSize\\tBlock\")",
    "    for i, a in enumerate(allocation):",
    "        print(f\"{i}\\t{processes[i]}\\t{a if a != -1 else 'Not Allocated'}\")",
    "",
    "worst_fit([100, 500, 200, 300, 600], [212, 417, 112, 426])"
  ],
  "description": "worst_fit"
}
}
