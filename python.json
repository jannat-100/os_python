{
	
	"sjf": {
  "prefix": "bdSJF",
  "body": [
    "def sjf(processes, burst_time):",
    "    n = len(processes)",
    "    zipped = sorted(zip(burst_time, processes))",
    "    burst_time, processes = zip(*zipped)",
    "",
    "    waiting_time = [0] * n",
    "    turnaround_time = [0] * n",
    "",
    "    for i in range(1, n):",
    "        waiting_time[i] = waiting_time[i - 1] + burst_time[i - 1]",
    "    ",
    "    for i in range(n):",
    "        turnaround_time[i] = waiting_time[i] + burst_time[i]",
    "",
    "    print(\"\\nSJF Schedule:\")",
    "    for i in range(n):",
    "        print(f\"P{processes[i]}: Waiting={waiting_time[i]}, Turnaround={turnaround_time[i]}\")",
    "",
    "#test",
    "processes = [1, 2, 3]",
    "burst_time = [5, 2, 8]",
    "sjf(processes, burst_time)"
  ],
  "description": "sjf"
},
"mru": {
  "prefix": "bdMRU",
  "body": [
    "def mru(pages, capacity):",
    "    memory = []",
    "    faults = 0",
    "    for p in pages:",
    "        if p not in memory:",
    "            if len(memory) == capacity:",
    "                memory.pop(-1)",
    "            faults += 1",
    "        else:",
    "            memory.remove(p)",
    "        memory.append(p)",
    "    print(\"Page Faults:\", faults)",
    "",
    "mru([1, 2, 3, 2, 4, 1, 5], 3)",
    ""
  ],
  "description": "mru"
},
"fifo": {
  "prefix": "bdFIFO",
  "body": [
    "def fifo(pages, capacity):",
    "    memory = []",
    "    faults = 0",
    "    for p in pages:",
    "        if p not in memory:",
    "            if len(memory) == capacity:",
    "                memory.pop(0)",
    "            memory.append(p)",
    "            faults += 1",
    "    print(\"Page Faults:\", faults)",
    "",
    "fifo([1, 3, 0, 3, 5, 6], 3)"
  ],
  "description": "fifo"
},
"first_best_worst": {
  "prefix": "bdFIT",
  "body": [
    "def first_fit(holes, process_size):",
    "    for hole in holes:",
    "        if hole >= process_size:",
    "            print(f\"First Fit: {hole}k\")",
    "            return",
    "    print(\"Hey wait, you don't have sufficient space\")",
    "",
    "",
    "def best_fit(holes, process_size):",
    "    holes.sort()",
    "    for hole in holes:",
    "        if hole >= process_size:",
    "            print(f\"Best Fit: {hole}k\")",
    "            return",
    "    print(\"Hey wait, you don't have sufficient space\")",
    "",
    "",
    "def worst_fit(holes, process_size):",
    "    holes.sort(reverse=True)",
    "    if process_size <= holes[0]:",
    "        print(f\"Worst Fit: {holes[0]}k\")",
    "    else:",
    "        print(\"Hey wait, you don't have sufficient space\")",
    "",
    "# Main Logic",
    "n = input(\"Enter the number of Holes available: \")",
    "holes = list(map(int, input(\"Enter the Hole Sizes: \").split()))",
    "",
    "process_size = int(input(\"Enter process size: \"))",
    "",
    "first_fit(holes[:], process_size)   # use holes[:] to pass a copy",
    "best_fit(holes[:], process_size)",
    "worst_fit(holes[:], process_size)"
  ],
  "description": "first_best_worst"
},
"banker": {
  "prefix": "bdBANK",
  "body": [
    "def bankers(n, m, alloc, maxm, avail):",
    "    need = [[maxm[i][j] - alloc[i][j] for j in range(m)] for i in range(n)]",
    "    finish = [False] * n",
    "    safe_seq = []",
    "    work = avail.copy()",
    "",
    "    while len(safe_seq) < n:",
    "        allocated = False",
    "        for i in range(n):",
    "            if not finish[i] and all(need[i][j] <= work[j] for j in range(m)):",
    "                for j in range(m):",
    "                    work[j] += alloc[i][j]",
    "                finish[i] = True",
    "                safe_seq.append(i)",
    "                allocated = True",
    "        if not allocated:",
    "            print(\"System is not in safe state\")",
    "            return",
    "    print(\"Safe sequence:\", \" -> \".join(f\"P{p}\" for p in safe_seq))",
    "",
    "# Example",
    "n = 5  # processes",
    "m = 3  # resources",
    "alloc = [[0, 1, 0], [2, 0, 0], [3, 0, 2], [2, 1, 1], [0, 0, 2]]",
    "maxm = [[7, 5, 3], [3, 2, 2], [9, 0, 2], [2, 2, 2], [4, 3, 3]]",
    "avail = [3, 3, 2]",
    "bankers(n, m, alloc, maxm, avail)"
  ],
  "description": "banker"
},
"fcfs": {
  "prefix": "bdFCFS",
  "body": [
    "# FCFS Scheduling",
    "def fcfs(processes, burst_time):",
    "    n = len(processes)",
    "    wt = [0] * n",
    "    TA = [0] * n",
    "",
    "    for i in range(1, n):",
    "        wt[i] = wt[i - 1] + burst_time[i - 1]",
    "    ",
    "    for i in range(n):",
    "        TA[i] = wt[i] + burst_time[i]",
    "",
    "    print(\"FCFS Schedule:\")",
    "    for i in range(n):",
    "        print(f\"P{processes[i]}: Waiting={wt[i]}, Turnaround={TA[i]}\")",
    "",
    "",
    "#test",
    "processes = [1, 2, 3]",
    "burst_time = [5, 2, 8]",
    "fcfs(processes, burst_time)"
  ],
  "description": "fcfs"
},
"LRU": {
  "prefix": "bdLRU",
  "body": [
    "def lru(pages, capacity):",
    "    memory = []",
    "    faults = 0",
    "    for p in pages:",
    "        if p not in memory:",
    "            if len(memory) == capacity:",
    "                memory.pop(0)",
    "            faults += 1",
    "        else:",
    "            memory.remove(p)",
    "        memory.append(p)",
    "    print(\"Page Faults:\", faults)",
    "",
    "lru([7, 0, 1, 2, 0, 3, 0, 4], 3)"
  ],
  "description": "LRU"
}
}
